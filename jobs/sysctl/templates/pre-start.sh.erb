#!/bin/bash

set -xeuo pipefail

JOB_MODULES_PATH="/var/vcap/jobs/*/config/os-conf/modules.conf"
JOB_SYSCTL_PATH="/var/vcap/jobs/*/config/os-conf/sysctl.conf"

trim_spaces() {
    sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//'
}

remove_comments() {
    sed '/^[[:space:]]*\(;\|#\)/d'
}

remove_empty_lines() {
    sed '/^[[:space:]]*$/d'
}

# Parse config files, generate list of job level settings / modules and echo the result
# Return 1 if conflicted values / options are found
parse_conf_files() {
    local conf_path=$1
    local delim=$2

    local -A param_files param_values
    local conf_file
    local conflict=false
    for conf_file in $(compgen -G "$conf_path"); do
        conf=$(cat "$conf_file" | remove_comments | remove_empty_lines)

        local param value
        while IFS=$delim read -r param value; do
            [[ -z $param ]] && continue

            param=$(trim_spaces <<< $param)
            value=$(trim_spaces <<< $value)

            if [[ -n ${param_files[$param]-} && ${param_values[$param]-} != $value ]]; then
                echo "ERROR: There is a conflict in parameter values / module options" >&2
                (
                    echo -e "${param_files[$param]}:\t$param $delim ${param_values[$param]}" >&2
                    echo -e "$conf_file:\t$param $delim $value" >&2
                ) | column -ts$'\t'
                conflict=true
            else
                param_files[$param]=$conf_file
                param_values[$param]=$value
            fi
        done <<< "$conf"
    done
    $conflict && return 1

    for param in "${!param_values[@]}"; do
        echo "$param $delim ${param_values[$param]}" | trim_spaces
    done
}

# Generate the list of job level modules (format: module_name option1 option2 ...)
job_module_list=$(parse_conf_files "$JOB_MODULES_PATH" " ") || exit 1
job_modules=$(sed <<< "$job_module_list" 's/ .*$//')                         # format: module_name
job_module_options=$(sed <<< "$job_module_list" -n '/ / s/^/options /p')     # format: options module_name option1 option2 ...

# Generate the list of job level settings (format: param = value)
job_sysctl_confs=$(parse_conf_files "$JOB_SYSCTL_PATH" "=") || exit 1

# Store the custom list of modules in /etc/modules-load.d so that they automatically go into effect at boot
mkdir -p /etc/modules-load.d
cat > /etc/modules-load.d/bosh-os-conf-modules.conf << EOF
# Autogenerated by bosh os-conf-release sysctl. Do not edit.

# Job level modules
$job_modules
EOF
cat > /etc/modprobe.d/bosh-os-conf-module-options.conf << EOF
# Autogenerated by bosh os-conf-release sysctl. Do not edit.

# Job level modules
$job_module_options
EOF

# Load all modules now (including the ones we just added above)
if [[ -n $job_modules ]]; then
    /etc/init.d/kmod stop 2>/dev/null || true  # Stopping is required for systemd bases systems
    /etc/init.d/kmod start
fi

# Store the custom sysctl in /etc/sysctl.d so that they automatically go into effect at boot
cat > /etc/sysctl.d/<%= p("sysctl_conf_prefix") %>-bosh-os-conf-sysctl.conf << EOF
# Autogenerated by bosh os-conf-release sysctl. Do not edit.

# Job level settings
$job_sysctl_confs

# Instance group level overrides
<%= p("sysctl").join "\n" %>
EOF

# Reapply all sysctls now (including the ones we just stored above)
sysctl --system
